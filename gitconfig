[user]
  email = darkrho@gmail.com
  name = Rolando Espinoza

[alias]
  st = status -s -b
  ci = commit
  co = checkout
  dc = diff --cached
  b = brach -vv
  bc = brach --contains
  f = fetch --all --tags
  r = rebase
  re = reset --hard @{upstream}
  short = rev-parse --short
  m = merge --no-ff

  # Perform a merge in-memory and output if any conflicts are found (dry-run)
  # Takes the name of a branch / ref to merge
  mergetest = "!sh -c 'git merge-tree `git merge-base $1 HEAD` $1 HEAD \
      | awk '\\''/^@@/ { print \"Conflicts found\"; exit 1 }'\\''' -"

  l = log --oneline --decorate
  ll = log --stat --decorate --abbrev-commit --date=relative
  lll = log -p --stat --decorate --abbrev-commit --date=relative
  llll = "!sh -c 'git lll $@ \
      | gvim - -R -v -c \"set ft=git\" -c \"set fdm=syntax\"' -"

  rl = reflog --date=relative
  stat = diff --stat

  serve = "!git daemon --base-path=$(git rev-parse --show-toplevel) --export-all"

  # Open all modified files in EDITOR
  editm = "!$EDITOR $(git ls-files -m)"

  # Alias to make an archive with a prefix set to the name of the repo
  tar = "!git archive --prefix=$(basename $(git rev-parse --show-toplevel))/"

  # Show all remote branches that have been merged
  allmerged = "!git branch -r -v --no-abbrev --merged | \
      awk '!/master*|develop*|HEAD/ { print $2,$1 }'"

  # Show the correct SHA for merging from FETCH_HEADS
  showfetchhead = "!awk '!/not-for-merge/ {print $1}' \
      $(git rev-parse --git-dir)/FETCH_HEAD"

  # Compare local branches to remote branches (without doing a fetch!)
  # Takes (optional) remote name as an argument; default: "upstream".
  # FIXME: branches that are ahead of upstream will also be shown.
  showstale = "!bash -c 'join -j 2 \
      <(git show-ref --heads) \
      <(git ls-remote --heads ${1:-upstream}) \
      | awk '\\''{ if ($2 != $3) print $1 }'\\''' -"

  ### Custom Git commands (found in ~/bin)
  # Push only the current branch to the upstream branch
  p = pushcurrent

  # Show individual diffs for all incoming/outgoing changesets
  in = pagediffs ..@{u}
  out = pagediffs @{u}..

  # Output the commit that git svn dcommit will attempt to commit on top of
  svnhead = !git --no-pager log --grep=^git-svn-id: --first-parent -1

  # Output URL to make a GitHub pull request
  # git preq remotename branchname
  preq = "!sh -c 'git remote show -n $1 | \
      awk -F: '\\''/Push'\\\\'s+URL/ { sub(/'\\\\'.git/, x, $3); \
      print \"https://github.com/\"$3\"/pull/new/\"br }'\\'' br=$2' -"

  # Output git command to pull a remote branch from a pull request
  # git mpreq remotename ghuser:branch
  mpreq = "!sh -c 'git remote show -n $1 | \
      awk -F/ '\\''/Push'\\\\'s+URL/ { \
      sub(/'\\\\'.git/, x, $2); split(fk, f, \":\"); \
      print \"git pull https://github.com/\"f[1]\"/\"$2, f[2] }'\\'' fk=$2' -"

  # Configure local clone to also make local refs for all GitHub pull
  # requests for the specified remote
  # Usage: git addrefspr upstream; git fetch upstream; git show upstream/pr/13
  addrefspr = "!sh -c 'git config --add \
      remote.$1.fetch \"+refs/pull/*/head:refs/remotes/$1/pr/*\"' -"

[core]
  excludesfile = /home/shouse/.gitignore

[color]
  ui = auto

[sendemail]
  smtpencryption = tls
  smtpserver = smtp.gmail.com
  smtpuser = darkrho@gmail.com
  smtpserverport = 587

[diff]
  tool = clivimdiff

[difftool "clivimdiff"]
  cmd = gvimdiff -v $LOCAL $REMOTE

[merge]
  tool = diffconflicts

[mergetool "diffconflicts"]
  cmd = diffconflicts $EDITOR $BASE $LOCAL $REMOTE $MERGED
  trustExitCode = true
  keepBackup = false

[mergetool "gdiffconflicts"]
  cmd = diffconflicts gvim $BASE $LOCAL $REMOTE $MERGED
  trustExitCode = true
  keepBackup = false

[push]
  default = current
